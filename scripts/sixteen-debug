#!/usr/bin/env python
# -*- coding: utf-8 -*-
"Primitive debugger."
#TODO: make this a lot nicer

import sys
import argparse
import re
from sixteen.dcpu16 import DCPU16
from sixteen.debugger import Debugger
from sixteen.utilities import HexRead


parser = argparse.ArgumentParser(
	description='Step through and debug a DCPU-16 binary.'
)

parser.add_argument('--little', '-l', dest="big_endian", action='store_false', 
	help="Denote that this file should be parsed as little-endian. "
	"(Default: big-endian).",
)

parser.add_argument('--hex', dest="bin", action='store_false', 
	help="Denote that this file should be parsed as an ASCII hex dump. "
	"(Default: binary)"
)

parser.add_argument('file',
	help="The binary file to step through."
)

args = parser.parse_args()

# open the file from the command-line, if it's supposed to be a bin
if args.bin:
	f = open(args.file)
else:
	f = HexRead(args.file)

# initialize a new CPU
d = DCPU16()


# read the file to the cpu's RAM
for n, _ in enumerate(d.RAM):
	# read two bytes as ints
	word = [ord(c) for c in f.read(2)]
	# if there are exactly two bytes, go on
	if len(word) == 2:
		# unpack the top and the bottom of the word
		if args.big_endian:
			top, bottom = word
		else:
			bottom, top = word
		# bitshift the top up and then add to the bottom
		word_int = (top << 8) + bottom
		# AMBIGUITY: is the byte order big-endian or not?
		# set this n in the ram to that number
		d.RAM[n] = word_int
	# if there aren't two bytes, stop
	else:
		break


# close the file
f.close()


# run the debugger on the cpu
debugger = Debugger(d)
debugger()
